# wrangler.toml

```toml
#:schema node_modules/wrangler/config-schema.json
name = "top-members-only"
main = "src/index.ts"
compatibility_date = "2024-07-29"

# Automatically place your workloads in an optimal location to minimize latency.
# If you are running back-end logic in a Worker, running it closer to your back-end infrastructure
# rather than the end user may result in better performance.
# Docs: https://developers.cloudflare.com/workers/configuration/smart-placement/#smart-placement
# [placement]
# mode = "smart"

# Variable bindings. These are arbitrary, plaintext strings (similar to environment variables)
# Docs:
# - https://developers.cloudflare.com/workers/wrangler/configuration/#environment-variables
# Note: Use secrets to store sensitive data.
# - https://developers.cloudflare.com/workers/configuration/secrets/
# [vars]
# MY_VARIABLE = "production_value"

# Bind the Workers AI model catalog. Run machine learning models, powered by serverless GPUs, on Cloudflare’s global network
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#workers-ai
# [ai]
# binding = "AI"

# Bind an Analytics Engine dataset. Use Analytics Engine to write analytics within your Pages Function.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#analytics-engine-datasets
# [[analytics_engine_datasets]]
# binding = "MY_DATASET"

# Bind a headless browser instance running on Cloudflare's global network.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#browser-rendering
# [browser]
# binding = "MY_BROWSER"

# Bind a D1 database. D1 is Cloudflare’s native serverless SQL database.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#d1-databases
[[d1_databases]]
binding = "DB" # i.e. available in your Worker on env.DB
database_name = "top_members-only"
database_id = "84abc105-4a97-4ecd-b5ef-0750df19af02"

# Bind a dispatch namespace. Use Workers for Platforms to deploy serverless functions programmatically on behalf of your customers.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#dispatch-namespace-bindings-workers-for-platforms
# [[dispatch_namespaces]]
# binding = "MY_DISPATCHER"
# namespace = "my-namespace"

# Bind a Durable Object. Durable objects are a scale-to-zero compute primitive based on the actor model.
# Durable Objects can live for as long as needed. Use these when you need a long-running "server", such as in realtime apps.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#durable-objects
# [[durable_objects.bindings]]
# name = "MY_DURABLE_OBJECT"
# class_name = "MyDurableObject"

# Durable Object migrations.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#migrations
# [[migrations]]
# tag = "v1"
# new_classes = ["MyDurableObject"]

# Bind a Hyperdrive configuration. Use to accelerate access to your existing databases from Cloudflare Workers.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#hyperdrive
# [[hyperdrive]]
# binding = "MY_HYPERDRIVE"
# id = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

# Bind a KV Namespace. Use KV as persistent storage for small key-value pairs.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#kv-namespaces
# [[kv_namespaces]]
# binding = "MY_KV_NAMESPACE"
# id = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

# Bind an mTLS certificate. Use to present a client certificate when communicating with another service.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#mtls-certificates
# [[mtls_certificates]]
# binding = "MY_CERTIFICATE"
# certificate_id = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"

# Bind a Queue producer. Use this binding to schedule an arbitrary task that may be processed later by a Queue consumer.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#queues
# [[queues.producers]]
# binding = "MY_QUEUE"
# queue = "my-queue"

# Bind a Queue consumer. Queue Consumers can retrieve tasks scheduled by Producers to act on them.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#queues
# [[queues.consumers]]
# queue = "my-queue"

# Bind an R2 Bucket. Use R2 to store arbitrarily large blobs of data, such as files.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#r2-buckets
# [[r2_buckets]]
# binding = "MY_BUCKET"
# bucket_name = "my-bucket"

# Bind another Worker service. Use this binding to call another Worker without network overhead.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#service-bindings
# [[services]]
# binding = "MY_SERVICE"
# service = "my-service"

# Bind a Vectorize index. Use to store and query vector embeddings for semantic search, classification and other vector search use-cases.
# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#vectorize-indexes
# [[vectorize]]
# binding = "MY_INDEX"
# index_name = "my-index"

```

# worker-configuration.d.ts

```ts
// Generated by Wrangler
// After adding bindings to `wrangler.toml`, regenerate this interface via `npm run cf-typegen`
interface CloudflareBindings {
}

```

# tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "skipLibCheck": true,
    "lib": ["ESNext", "esnext"],
    "types": ["@cloudflare/workers-types/2023-07-01"],
    "jsx": "react-jsx",
    "jsxImportSource": "hono/jsx"
  }
}

```

# package.json

```json
{
  "name": "top-members-only",
  "scripts": {
    "dev": "wrangler dev",
    "deploy": "wrangler deploy --minify",
    "cf-typegen": "wrangler types --env-interface CloudflareBindings"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "hono": "^4.5.3",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20240729.0",
    "@types/bcryptjs": "^2.4.6",
    "@types/react": "^18.3.3",
    "wrangler": "^3.57.2"
  }
}

```

# README.md

```md
Members only application created as part of The Odin Project curriculum.

```

# .gitignore

```
# prod
dist/

# dev
.yarn/
!.yarn/releases
.vscode/*
!.vscode/launch.json
!.vscode/*.code-snippets
.idea/workspace.xml
.idea/usage.statistics.xml
.idea/shelf

# deps
node_modules/
.wrangler

# env
.env
.env.production
.dev.vars

# logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# misc
.DS_Store

```

# src/index.ts

```ts
import { Hono } from "hono";
import { z } from "zod";
import { hash, compare } from "bcryptjs";
import {
  BaseLayout,
  MessageList,
  SignupForm,
  LoginForm,
  JoinClubForm,
  NewMessageForm,
  User,
  Message,
} from "./components";

type Bindings = {
  DB: D1Database;
};

type Session = {
  userId: number;
};

type Variables = {
  user: User | null;
  session: Session | null;
};

const app = new Hono<{ Bindings: Bindings; Variables: Variables }>();

// Middleware for authentication
app.use("*", async (c, next) => {
  const session = c.get("session");
  let user: User | null = null;

  if (session && session.userId) {
    user = await c.env.DB.prepare("SELECT * FROM users WHERE id = ?")
      .bind(session.userId)
      .first<User | null>();
  }

  c.set("user", user);
  await next();
});

// Routes
app.get("/", async (c) => {
  const messages = await c.env.DB.prepare(
    "SELECT * FROM messages ORDER BY createdAt DESC"
  ).all<Message>();
  const user = c.get("user");

  return c.html(
    BaseLayout({
      user,
      children: MessageList({ messages: messages.results, user }),
    })
  );
});

app.get("/signup", (c) => {
  return c.html(
    BaseLayout({ user: null, children: SignupForm({ error: undefined }) })
  );
});

app.post("/signup", async (c) => {
  const body = await c.req.parseBody();
  const schema = z
    .object({
      firstName: z.string().min(1),
      lastName: z.string().min(1),
      email: z.string().email(),
      password: z.string().min(6),
      confirmPassword: z.string().min(6),
    })
    .refine((data) => data.password === data.confirmPassword, {
      message: "Passwords don't match",
      path: ["confirmPassword"],
    });

  try {
    const data = schema.parse(body);
    const hashedPassword = await hash(data.password, 10);
    const result = await c.env.DB.prepare(
      "INSERT INTO users (firstName, lastName, email, password) VALUES (?, ?, ?, ?)"
    )
      .bind(data.firstName, data.lastName, data.email, hashedPassword)
      .run();

    if (result.success) {
      // Get the last inserted ID from the meta property
      const lastInsertId = result.meta?.last_row_id;
      if (lastInsertId) {
        // Set session after successful signup
        c.set("session", { userId: Number(lastInsertId) });
        return c.redirect("/");
      } else {
        throw new Error("Failed to get last inserted ID");
      }
    } else {
      throw new Error("Failed to create user");
    }
  } catch (error) {
    return c.html(SignupForm({ error: (error as Error).message }));
  }
});

app.get("/login", (c) => {
  return c.html(
    BaseLayout({ user: null, children: LoginForm({ error: undefined }) })
  );
});

app.post("/login", async (c) => {
  const body = await c.req.parseBody();
  const schema = z.object({
    email: z.string().email(),
    password: z.string(),
  });

  try {
    const data = schema.parse(body);
    const user = await c.env.DB.prepare("SELECT * FROM users WHERE email = ?")
      .bind(data.email)
      .first<User | null>();
    if (!user || !(await compare(data.password, user.password))) {
      throw new Error("Invalid email or password");
    }
    // Set session
    c.set("session", { userId: user.id });
    return c.redirect("/");
  } catch (error) {
    return c.html(
      BaseLayout({
        user: null,
        children: LoginForm({ error: (error as Error).message }),
      })
    );
  }
});

app.get("/join-club", (c) => {
  return c.html(
    BaseLayout({
      user: c.get("user"),
      children: JoinClubForm({ error: undefined }),
    })
  );
});

app.post("/join-club", async (c) => {
  const body = await c.req.parseBody();
  const user = c.get("user");
  const secretCode = "supersecret"; // In a real app, this should be stored securely

  if (user && body.secretCode === secretCode) {
    await c.env.DB.prepare("UPDATE users SET isMember = true WHERE id = ?")
      .bind(user.id)
      .run();
    return c.redirect("/");
  } else {
    return c.html(
      BaseLayout({
        user,
        children: JoinClubForm({ error: "Invalid secret code" }),
      })
    );
  }
});

app.get("/new-message", (c) => {
  const user = c.get("user");
  if (!user) return c.redirect("/login");
  return c.html(
    BaseLayout({ user, children: NewMessageForm({ error: undefined }) })
  );
});

app.post("/new-message", async (c) => {
  const user = c.get("user");
  if (!user) return c.redirect("/login");

  const body = await c.req.parseBody();
  const schema = z.object({
    title: z.string().min(1),
    content: z.string().min(1),
  });

  try {
    const data = schema.parse(body);
    await c.env.DB.prepare(
      "INSERT INTO messages (title, content, userId) VALUES (?, ?, ?)"
    )
      .bind(data.title, data.content, user.id)
      .run();
    return c.redirect("/");
  } catch (error) {
    return c.html(
      BaseLayout({
        user,
        children: NewMessageForm({ error: (error as Error).message }),
      })
    );
  }
});

app.post("/delete-message/:id", async (c) => {
  const user = c.get("user");
  if (!user || !user.isAdmin) return c.redirect("/");

  const messageId = c.req.param("id");
  await c.env.DB.prepare("DELETE FROM messages WHERE id = ?")
    .bind(messageId)
    .run();
  return c.redirect("/");
});

export default app;

```

# src/components.tsx

```tsx
/** @jsxImportSource hono/jsx */
import { html } from "hono/html";

export type User = {
  id: number;
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  isMember: boolean;
  isAdmin: boolean;
};

export type Message = {
  id: number;
  title: string;
  content: string;
  userId: number;
  createdAt: string;
};

type BaseLayoutProps = {
  user: User | null;
  children: any;
};

export const BaseLayout = ({ user, children }: BaseLayoutProps) => html`
  <html>
    <head>
      <title>Members Only</title>
      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css"
      />
    </head>
    <body>
      <nav>
        <a href="/">Home</a>
        ${user
          ? html`
              <a href="/new-message">New Message</a>
              <a href="/join-club">Join Club</a>
              <span>Welcome, ${user.firstName}!</span>
            `
          : html`
              <a href="/login">Login</a>
              <a href="/signup">Sign Up</a>
            `}
      </nav>
      ${children}
    </body>
  </html>
`;

type MessageListProps = {
  messages: Message[];
  user: User | null;
};

export const MessageList = ({ messages, user }: MessageListProps) => html`
  <div>
    ${messages.map(
      (message) => html`
        <div key="${message.id}">
          <h2>${message.title}</h2>
          <p>${message.content}</p>
          ${user && user.isMember
            ? html`<p>
                By: ${message.userId} on
                ${new Date(message.createdAt).toLocaleString()}
              </p>`
            : ""}
          ${user && user.isAdmin
            ? html`
                <form method="POST" action="/delete-message/${message.id}">
                  <button type="submit">Delete</button>
                </form>
              `
            : ""}
        </div>
      `
    )}
  </div>
`;

type FormProps = {
  error?: string;
};

export const SignupForm = ({ error }: FormProps) => html`
  <h1>Sign Up</h1>
  ${error ? html`<p style="color: red;">${error}</p>` : ""}
  <form method="POST">
    <input name="firstName" type="text" placeholder="First Name" required />
    <input name="lastName" type="text" placeholder="Last Name" required />
    <input name="email" type="email" placeholder="Email" required />
    <input name="password" type="password" placeholder="Password" required />
    <input
      name="confirmPassword"
      type="password"
      placeholder="Confirm Password"
      required
    />
    <button type="submit">Sign Up</button>
  </form>
`;

export const LoginForm = ({ error }: FormProps) => html`
  <h1>Login</h1>
  ${error ? html`<p style="color: red;">${error}</p>` : ""}
  <form method="POST">
    <input name="email" type="email" placeholder="Email" required />
    <input name="password" type="password" placeholder="Password" required />
    <button type="submit">Login</button>
  </form>
`;

export const JoinClubForm = ({ error }: FormProps) => html`
  <h1>Join the Club</h1>
  ${error ? html`<p style="color: red;">${error}</p>` : ""}
  <form method="POST">
    <input
      name="secretCode"
      type="password"
      placeholder="Secret Code"
      required
    />
    <button type="submit">Join</button>
  </form>
`;

export const NewMessageForm = ({ error }: FormProps) => html`
  <h1>New Message</h1>
  ${error ? html`<p style="color: red;">${error}</p>` : ""}
  <form method="POST">
    <input name="title" type="text" placeholder="Title" required />
    <textarea name="content" placeholder="Content" required></textarea>
    <button type="submit">Create Message</button>
  </form>
`;

```

# src/db/schema.sql

```sql
-- Users table
CREATE TABLE users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  firstName TEXT NOT NULL,
  lastName TEXT NOT NULL,
  email TEXT UNIQUE NOT NULL,
  password TEXT NOT NULL,
  isMember BOOLEAN DEFAULT false,
  isAdmin BOOLEAN DEFAULT false,
  createdAt DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Messages table
CREATE TABLE messages (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  userId INTEGER NOT NULL,
  createdAt DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (userId) REFERENCES users(id)
);

-- Index for faster queries
CREATE INDEX idx_messages_userId ON messages(userId);
```

# .wrangler/state/v3/d1/miniflare-D1DatabaseObject/8add53c4525f834d73eaeaca1999156d502bd73ed432948d7da70303c4d6d84a.sqlite

This is a binary file of the type: Binary

